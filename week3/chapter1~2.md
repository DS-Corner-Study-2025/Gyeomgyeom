
### 1.1 서버와 클라이언트 관계


#### 서버

네트워크로 클라이언트한테 정보나 서비스 주는 컴퓨터나 프로그램

#### 클라이언트

요청을 보내는 주체. 웹 브라우저, 모바일 앱, 다른 서버 같은 것들

#### 상호작용 과정 (서빙 과정)

1.  **클라이언트의 요청**: 손님이 '햄버거 하나' 주문
2.  **서버의 처리**: 주방(서버)이 주문 확인하고 햄버거 만듦.
3.  **서버의 응답**: 주방이 다 만든 햄버거를 손님한테 가져다줌.

### 1.1.3 이벤트 기반



특정 **이벤트**가 생겼을 때 미리 정해둔 작업을 하는 방식. 이벤트가 발생하면 뭘 할지 **이벤트 리스너에 콜백 함수를 등록**해놔야 함.

  * **이벤트 루프**: 여러 이벤트가 동시에 생길 때 콜백 함수를 어떤 순서로 부를지 결정해줌. 노드(Node.js)가 꺼질 때까지 계속 이 일을 반복해서 루프라고 부름.
  * **백그라운드**: `setTimeout` 같은 타이머나 이벤트 리스너들이 대기하는 곳. 자바스크립트 아닌 다른 언어로 만들어져서 여러 작업을 동시에 처리할 수 있음.
  * **태스크 큐 (콜백 큐)**: 이벤트가 생긴 후 백그라운드에서 콜백 함수들을 보내는 곳. 정해진 순서대로 줄 서있음.

### 1.1.4 논 블로킹 I/O


**I/O**는 입력(Input)과 출력(Output)을 뜻함. 파일 읽기/쓰기 같은 작업이 이에 속함.

  * **논 블로킹**: 이전 작업이 끝날 때까지 기다리지 않고 바로 다음 작업함.
  * **블로킹**: 이전 작업이 끝나야만 다음 작업을 시작함.

### 1.1.5 싱글 스레드 (프로세스와 스레드)



  * **프로세스**

      * 운영체제가 할당하는 **독립된 작업의 단위**
      * 각각 고유한 메모리 공간을 가져서 서로 **공유 안 함**.
      * 하나가 문제 생겨도 다른 프로세스에 영향 안 줘서 안정적임.
      * **예**: 웹 브라우저, Node.js 애플리케이션 등.

  * **스레드**

      * 하나의 프로세스 안에서 돌아가는 **흐름의 단위**
      * 부모 프로세스 자원을 **공유**해서 데이터 공유가 엄청 쉬움.
      * 여러 작업을 동시에 처리해서 효율을 높일 수 있음.

### 2.1.1 const, let

  * **`const`**: **상수**를 선언할 때 씀. 한 번 값 정하면 다른 값으로 못 바꿈. 선언할 때 무조건 초기값 줘야 함.
    ```javascript
    const a = 0;
    // 'a'는 값 못 바꿔서 에러 남.
    a = 1;

    // 초기값 없어서 에러 남.
    const c;
    ```
  * **`let`**: **변수**를 선언할 때 씀. 한 번 값 할당해도 언제든 바꿀 수 있음.
    ```javascript
    let b = 0;
    // 'b'의 값을 1로 바꿈.
    b = 1;
    ```

### 2.1.4 화살표 함수


`function` 대신 `=>`로 함수 선언하는 방식. `return`문만 있으면 생략해서 한 줄로 쓸 수 있음.

```javascript
// 기본 함수
function add1(x, y) {
	return x + y;
}

// 화살표 함수 (기본)
const add2 = (x, y) => {
	return x + y;
};

// 화살표 함수 (축약형)
const add3 = (x, y) => x + y;
const add4 = (x, y) => (x + y);

// 매개변수 하나일 때 괄호 생략 가능
function not1(x) {
	return !x;
}
const not2 = x => !x;
```

### 2.1.7 프로미스


#### `new Promise`

새로운 프로미스 객체 만드는 생성자. `(resolve, reject)` 두 함수를 인자로 받는데, 얘네로 프로미스 상태를 바꿔줌.

  * **`resolve()`**: 비동기 작업이 성공했을 때 부름. 상태가 `fulfilled`로 바뀌면서 `.then()` 메서드가 돌아감.
  * **`reject()`**: 비동기 작업이 실패했을 때 부름. 상태가 `rejected`로 바뀌면서 `.catch()` 메서드가 돌아감.

#### `Promise.all()`

여러 개의 프로미스를 **동시에** 돌리고, **모두 성공했을 때** 결과들을 배열로 돌려줌.

  * **실패**: 하나라도 실패하면 나머지 성공 여부 상관없이 바로 `rejected` 상태가 됨.
  * **순서**: 모두 성공하면 결과 값은 `Promise.all()`에 넣었던 순서대로 배열에 담겨서 나옴.

<!-- end list -->

```javascript
const promise1 = Promise.resolve('성공1');
const promise2 = Promise.resolve('성공2');

Promise.all([promise1, promise2])
    .then((result) => {
        console.log(result); // ['성공1', '성공2']
    })
    .catch((error) => {
        console.error(error);
    });
```